# Производительность и профилирование

## Рекомендации

- **Обучение** выполняется в отдельном потоке; UI не блокируется. Прогресс и лог выводятся через очередь.
- **Детекция** использует три потока: захват кадров, инференс, отображение в окне OpenCV. Очереди ограничены по размеру (1–2 кадра), чтобы не накапливать задержку.
- **Список обученных моделей** (`scan_trained_weights`) кэшируется на 3 с, чтобы не сканировать `runs/train` при каждом открытии выпадающего списка.

## Профилирование

Для поиска узких мест можно использовать стандартный модуль `cProfile`:

```bash
python -m cProfile -o profile.stats main.py
```

После закрытия приложения анализировать результат:

```python
import pstats
p = pstats.Stats("profile.stats")
p.sort_stats("cumulative")
p.print_callers(30)   # или print_callees, print_stats
```

Для визуализации подойдут `gprof2dot` + Graphviz или `snakeviz`:

```bash
pip install snakeviz
snakeviz profile.stats
```

Профилирование имеет смысл при длительном обучении или при заметных подвисаниях UI (например, при открытии превью с большим числом изображений).
