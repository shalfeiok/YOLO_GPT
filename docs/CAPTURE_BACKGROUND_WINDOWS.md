# Захват окна в фоне и под другими окнами

В приложении уже реализован захват **из буфера процесса окна** (даже когда окно под другими окнами или неактивно). Ниже — что используется сейчас и какие есть варианты для максимального быстродействия и совместимости.

## Текущая реализация (`app/services/capture_service.py`)

Порядок попыток захвата выбранного окна:

1. **PrintWindow с PW_RENDERFULLCONTENT (0x2)** — захват полного содержимого окна из его собственного буфера (в т.ч. UWP/DirectX). Окно может быть в фоне или перекрыто.
2. **PrintWindow с флагом 0** — классический GDI-буфер окна.
3. **BitBlt** — копирование из DC окна (даёт то, что реально отрисовано на экране; если окно перекрыто — будет видно то, что сверху).
4. **RedrawWindow + PrintWindow** — принудительная перерисовка, затем PrintWindow.
5. Для **свёрнутого** окна: временно **ShowWindow(SW_RESTORE)** → PrintWindow → **ShowWindow(SW_MINIMIZE)**.

Если ни один способ не дал непустой кадр — fallback: **захват области экрана** по координатам окна (mss/GDI). В этом случае будет видно то, что поверх окна.

Итог: для обычных и многих современных окон **захват «прямо из процесса окна»** уже делается через PrintWindow; наложение других окон не мешает.

---

## Варианты для расширения (при необходимости)

| Вариант | Плюсы | Минусы |
|--------|--------|--------|
| **PrintWindow (текущий)** | Работает в фоне, без доступа к экрану, под другими окнами. Минимум зависимостей (win32gui/ctypes). | Не все приложения отдают полный контент (особенно с GPU/OpenGL/DirectX без поддержки); возможны чёрные/пустые области. |
| **Windows Graphics Capture (WinRT)** | Официальный API Windows 10+ для захвата окна или экрана; окно может быть перекрыто; хорошая совместимость с D3D. | Нужен отдельный бэкенд (например, через `winrt-Windows.Graphics.Capture` или pywin32 + WinRT), асинхронный API, настройка разрешений. |
| **Desktop Duplication API (DDA)** | Высокая скорость, низкая задержка, подходит для полноэкранного/монитора. | Захват всего экрана или монитора; чтобы «только окно» — нужно резать по GetWindowRect; если окно перекрыто, в кадр попадёт то, что сверху. Не даёт «из процесса окна». |
| **Захват области экрана (mss/GDI)** | Уже есть как fallback. | Показывает то, что реально на экране (поверх окна тоже). |

Рекомендация при текущем стеке:

- Оставить **PrintWindow первым** для максимального быстродействия и захвата «из процесса» при работе в фоне.
- При необходимости поддержки проблемных (например, игровых) окон можно добавить опциональный бэкенд **Windows Graphics Capture** (WinRT) и выбирать его в настройках источника.
- DDA имеет смысл только для сценариев «весь экран/монитор» с минимальной задержкой, а не для произвольного окна в фоне.

---

## Быстродействие

- **PrintWindow** — один вызов API, копирование из буфера окна в DC, без сканирования экрана — обычно быстрее, чем захват области экрана.
- Очередь превью с `maxsize=1` и отсутствие лишних копий кадра в конвейере детекции уже уменьшают задержки.
- Для ещё большей скорости при захвате экрана (не окна) можно использовать D3DShot (уже опционально в бэкенде визуализации) или DDA.

Текущий порядок методов в `capture_service` настроен так, чтобы сначала использовался самый быстрый и подходящий для фонового окна способ (PrintWindow), а затем — остальные с fallback на регион экрана.
