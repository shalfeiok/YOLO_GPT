# Полное code review (актуальное состояние)

Дата: auto-generated by agent.

## Статус выполнения
- [x] 1) Jobs tab: добавлено агрегирование `Training*` в `JobRegistry` + отображение обновлений в `JobsView`; для детекции добавлены lifecycle `JobStarted/JobFinished` события при запуске/остановке.
- [x] 2) SAHI: `confidence_threshold` теперь сериализуется.
- [x] 3) Tuning: `enabled` теперь сериализуется/десериализуется.
- [x] 4) Единый ключ policy: канонический ключ `jobs`, чтение legacy `jobs_policy` оставлено как fallback + очистка legacy при сохранении.
- [x] 5) Детекция: убран синхронный refresh списка окон из `_start_detection()`.
- [~] 6) Consolidation review-файлов: `REVIEW_NOTES.md` оставлен как исторический; текущий статус ведется в этом файле.
- [x] 7) Detection Jobs status parity: пользовательская остановка теперь публикуется как `cancelled`, а аварии pipeline — как `failed` (вместо безусловного `finished`).

- [x] 8) Training bridge resilience: при старте нового обучения незавершённый предыдущий training-job корректно закрывается как `cancelled` (без «вечного running").

- [x] 9) Training cancel reason durability: причина отмены обучения теперь сохраняется в event-store через `JobProgress` перед `JobCancelled` и не теряется в истории.

- [x] 10) Replay backward-compat: восстановление Job history теперь толерантно к legacy/event-строкам без `name` (берется существующее имя job или fallback `Job`).

- [x] 11) Replay idempotency: восстановление history больше не дописывает повторно те же `Job*` события в store во время replay.

- [x] 12) Replay race-safety: live `Job*` события во время replay теперь не теряются в persistence (replay не блокирует обычный `_persist`).

- [x] 13) Replay robustness: `JobRegistry` безопасно переживает исключения `store.load()` и мусорные/non-dict записи без падения старта приложения.

- [x] 14) Replay input validation: `JobRegistry` теперь игнорирует не-list payload из `store.load()` (например `None`) без исключений на старте.

- [x] 15) Detection job-id uniqueness: id детекции теперь включает timestamp + run_id, чтобы избежать коллизий history между сессиями.

## 1) Критично: Jobs tab не отражает Training/Detection как «задачи»

### Наблюдение
- Окно задач (`JobsView`) подписано только на `Job*` события (`JobStarted`, `JobProgress`, ...). 
- Обучение публикует отдельные `Training*` события, а детекция вообще не идет через `JobRunner/ProcessJobRunner`.

### Риск
Пользователь запускает training/detection и ожидает увидеть активность в окне задач, но список пуст или неполный — UX как «ничего не работает».

### Где видно в коде
- `JobsView` подписывается только на `Job*` классы.
- `TrainingViewModel` работает через `Training*` события.
- `DetectionView` запускает собственные потоки без `JobRunner`.

### Рекомендация
- Либо: унифицировать и запускать training/detection через job runner.
- Либо: расширить JobsView/JobRegistry, чтобы агрегировать `Training*` (и, при необходимости, detection lifecycle) в те же записи.

---

## 2) Высокий приоритет: SAHI config теряет `confidence_threshold` при сохранении

### Наблюдение
`SahiConfig` содержит поле `confidence_threshold`, `from_dict` его читает, но `to_dict` НЕ сериализует.

### Риск
Параметр не сохраняется между перезапусками, пользователю кажется, что «настройка не работает».

### Рекомендация
Добавить `confidence_threshold` в `SahiConfig.to_dict()`.

---

## 3) Высокий приоритет: TuningConfig `enabled` фактически не персистится

### Наблюдение
`TuningConfig` содержит `enabled`, но:
- `to_dict()` не записывает `enabled`.
- `from_dict()` не читает `enabled`.

### Риск
Toggle «включено/выключено» в UI будет сбрасываться/расходиться с ожиданиями пользователя.

### Рекомендация
Добавить поле `enabled` в `to_dict` и `from_dict`.

---

## 4) Средний приоритет: Две несовместимые схемы ключа policy (`jobs` vs `jobs_policy`)

### Наблюдение
- Adapter (`IntegrationsAdapter`) читает/пишет policy в ключ `jobs_policy`.
- Facade (`app/application/facades/integrations.py`) пишет policy в ключ `jobs`.

### Риск
При смешанном использовании фасада/адаптера настройки политики задач могут «теряться» или читаться из разных мест.

### Рекомендация
Выбрать единый ключ и добавить миграцию/фолбэк чтения legacy-ключа.

---

## 5) Средний приоритет: тяжелая операция в старте детекции остается синхронной

### Наблюдение
Открытие вкладки ускорено (отложенный `_refresh_windows`), но в `_start_detection()` всё еще есть синхронный `self._update_window_list_only()`.

### Риск
Нажатие «Старт детекции» может лагать на системах с большим количеством окон/хук-оверлеев.

### Рекомендация
Перенести обновление списка окон в фоновый шаг/кэш или пропускать его на старте при уже выбранном источнике.

---

## 6) Низкий приоритет: REVIEW_NOTES.md устарел по фактическим фиксам

### Наблюдение
Исторический файл ревью содержит уже частично неактуальные пункты, что затрудняет triage.

### Рекомендация
Поддерживать один «живой» review-файл с датой/статусами: Open / Fixed / Won't fix.

---

## Мини-чеклист для следующего PR
- [x] Персист `confidence_threshold` в SAHI.
- [x] Персист `enabled` в TuningConfig.
- [x] Единый ключ policy-конфига (`jobs_policy` или `jobs`) + миграция.
- [x] Принять решение по показу Training/Detection в Jobs tab (унификация событий).
- [x] (Опционально) убрать синхронный refresh окон при старте детекции.


## Дополнительный аудит (итерация quality-pass)

Проверено:
- Полный прогон тестов (`pytest -q -ra`) — зелёный, 1 ожидаемый skip в headless окружении (libGL).
- Контракт replay job-history: обработка исключений `load()`, мусорных/non-dict записей, now non-list payload.

Результат:
- Найден и закрыт edge-case: `store.load()` может вернуть не-`list` (например `None`), что раньше приводило бы к `TypeError` при `for rec in records`.
